import java.io.EOFException;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.Socket;
import java.util.ArrayList;

public class MazeServerHandlerThread extends Thread {
	
	private Socket socket = null;
	private MazeServer mazeData;
	//private int clientID;
	//private Queue<MazePacket> requestQueue;
	//private Integer sequenceNum;

	public MazeServerHandlerThread(Socket socket, MazeServer maze) {
		//	Integer clientID, Queue<MazePacket> q) {
		super("MazeServerHandlerThread");
		this.socket = socket;
		this.mazeData = maze;
		//this.clientID = clientID;
		//this.requestQueue = q;
		// System.out.println("Created new Thread to handle client");
	}

	public void run() {

		boolean gotByePacket = false;

		try {
			/* stream to read from client */
			ObjectInputStream fromClient = new ObjectInputStream(
					socket.getInputStream());
			MazePacket packetFromClient;

			/* stream to write back to client */
			ObjectOutputStream toClient = new ObjectOutputStream(
					socket.getOutputStream());
			MazePacket packetToClient = null;

			/* Next packet in queue */
			MazePacket nextInLine = null;
			Boolean queued = true;

			while ((packetFromClient = (MazePacket) fromClient.readObject()) != null) {

				/* process symbol */
				Integer type = packetFromClient.getmsgType();
				// Check if type is incorrect. If it is, do not update sequence number.
				if ((type != MazePacket.CONNECTION_REQUEST) && (type != MazePacket.MAZE_REQUEST) && (type != MazePacket.MAZE_DISCONNECT)) {
					packetToClient = new MazePacket();
					packetToClient.seterrorCode(MazePacket.ERROR_INVALID_TYPE);
					toClient.writeObject(packetToClient);
					System.err.println("Error: Invalid packet type received from " + packetToClient.getclientInfo().name
									+ ". Dropping packet.");
					return;
				}
				// type must be valid here
				else {
					synchronized (mazeData.sequenceNum) {
						synchronized(mazeData.requestQueue) {
							// Update sequence number
							packetToClient.setseqNum(mazeData.sequenceNum);
							mazeData.sequenceNum++;
							// Update request queue
							queued = mazeData.requestQueue.add(packetToClient);
							nextInLine = mazeData.requestQueue.poll(); // remove() doesn't tell you if the requestQueue is empty. poll does. 
						}
					}
					if (queued != true) {
						System.err.println("Request could not be queued. Aborting.");
						System.exit(-1);
					}
					
					if (nextInLine == null)
						throw new NullPointerException();
				}

				switch (nextInLine.getmsgType()) {
					case MazePacket.CONNECTION_REQUEST: {
						Integer numRemotes;
					
						// Assign client ID
						synchronized (mazeData.clientID) {
							nextInLine.setclientID(mazeData.clientID);
							// Update global client ID
							mazeData.clientID++;
					
							synchronized(mazeData.addressBook) {
								// Ask all clients to create a new remote client
								nextInLine.setmsgType(MazePacket.NEW_REMOTE_CONNECTION);
								broadcastPacket(nextInLine, mazeData.addressBook);
						
								// Gather remote client data for the new connection
								numRemotes = mazeData.addressBook.size();
								nextInLine.remotes = new Address[numRemotes];						
								for (int i = 0; i < numRemotes; i++) {
									nextInLine.remotes[i] = new Address(mazeData.addressBook.get(i));
								}
								// Add new connection data to the addressBook
								mazeData.addressBook.add(nextInLine.getclientInfo());	
							}			// addressBook released here
						}			// client ID released here
					
						packetToClient = nextInLine;
						packetToClient.setmsgType(MazePacket.CONNECTION_REPLY);
						toClient.writeObject(packetToClient);
						packetToClient = null;
						break;
					}
				
					case MazePacket.MAZE_REQUEST: {
						packetToClient = nextInLine;
						// Set message type
						packetToClient.setmsgType(MazePacket.MAZE_REPLY);
						// Broadcast move to all players
						synchronized (mazeData.addressBook) {
							broadcastPacket(packetToClient, mazeData.addressBook);
						}
						break;
					}
				
					case MazePacket.MAZE_DISCONNECT: {
						// Broadcast to all players to remove this remoteclient
						// Delete client's data from addressbook (synchronized)
						break;
					}
					default: {
						// Should not get here
						System.err.println("Error: Unknown packet in requestQueue, generated by player " + nextInLine.getclientInfo().name
									+ ". Dropping packet.");
						System.exit(1); 
					}
				}		// end of switch statement
			}		// end of while loop

			/* cleanup when client exits */
			fromClient.close();
			toClient.close();
			socket.close();

		} catch (NullPointerException n) {

		} catch (EOFException e) {

		} catch (IOException e) {
			if (!gotByePacket)
				e.printStackTrace();
		} catch (ClassNotFoundException e) {
			if (!gotByePacket)
				e.printStackTrace();
		}
	}
	
	private void broadcastPacket(MazePacket outPacket, ArrayList<Address> addressBook) {
		
	}

}
