import java.io.EOFException;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.Socket;
import java.util.Queue;

public class MazeServerListenerThread extends Thread {
	
	private Socket socket = null;
	private int clientID;
	private Queue<MazePacket> queue;
	private Integer sequenceNum;

	public MazeServerListenerThread(Socket socket, Integer clientID,
			Queue<MazePacket> q) {
		super("MazeServerHandlerThread");
		this.socket = socket;
		this.clientID = clientID;
		this.queue = q;
		// System.out.println("Created new Thread to handle client");
	}

	public void run() {

		boolean gotByePacket = false;

		try {
			/* stream to read from client */
			ObjectInputStream fromClient = new ObjectInputStream(
					socket.getInputStream());
			MazePacket packetFromClient;

			/* stream to write back to client */
			ObjectOutputStream toClient = new ObjectOutputStream(
					socket.getOutputStream());
			MazePacket packetToClient = new MazePacket();

			/* Next packet in queue */
			MazePacket nextInLine = null;

			while ((packetFromClient = (MazePacket) fromClient.readObject()) != null) {

				/* process symbol */
				Integer type = packetFromClient.getmsgType();
				// Check if type is incorrect
				if ((type != MazePacket.CONNECTION_REQUEST)
						&& (type != MazePacket.MAZE_REQUEST)
						&& (type != MazePacket.MAZE_DISCONNECT)) {
					packetToClient.seterrorCode(MazePacket.ERROR_INVALID_TYPE);
					// do not update sequence number
					toClient.writeObject(packetToClient);
					System.err
							.println("Error: Invalid packet type received from " + packetToClient.getclientInfo().name
									+ ". Dropping packet.");
					return;
				}
				// type must be valid here
				else {
					// Set sequence number
					packetToClient.setseqNum(sequenceNum);
					// Update sequence number
					// Queue request
					// Dequeue request
				}

				switch (nextInLine.getmsgType()) {
				case MazePacket.CONNECTION_REQUEST: {
					// Add client to addressbook (synchronized)
					// Ask all clients to create a new remoteclient
					// Tell this client how many remotes to create (&
					// positions?)
					// Set client ID and message type and send return packet
					break;
				}
				case MazePacket.MAZE_REQUEST: {
					// Change message type to MAZE_REPLY
					// Broadcast move to all players
					break;
				}
				case MazePacket.MAZE_DISCONNECT: {
					// Broadcast to all players to remove this remoteclient
					// Delete client's data from addressbook (synchronized)
					break;
				}
				default: {
					// Should not get here
					System.err
							.println("Error: Unknown packet in queue, generated by player "
									+ nextInLine.getclientInfo().name
									+ ". Dropping packet.");
					System.exit(1); // should it really exit?
				}
				}

				if (packetFromClient.getmsgType() == MazePacket.CONNECTION_REQUEST) {
					/* create a packet to send clientID back to client */

					// packetToClient.setclientInfo(clientID);
					packetToClient.setmsgType(MazePacket.CONNECTION_REPLY);
					toClient.writeObject(packetToClient);

					/* wait for next packet */
					continue;
				} else if (packetFromClient.getmsgType() == MazePacket.MAZE_REQUEST) {
					/* create a packet to send latest move back to client */
					// ClientEvent

					// !! Change this to a lock, maybe? Decide later
					synchronized (this) {
						queue.add(packetFromClient);
						packetToClient = queue.remove();
					}

					// !! Send to all clients, not just one
					packetToClient.setmsgType(MazePacket.MAZE_REPLY);
					toClient.writeObject(packetToClient);
				}

				/* if code comes here, there is an error in the packet */
				System.err.println("ERROR: Unknown MAZE_* packet!!");

				System.exit(-1);
			}

			/* cleanup when client exits */
			fromClient.close();
			toClient.close();
			socket.close();

		} catch (NullPointerException n) {

		} catch (EOFException e) {

		} catch (IOException e) {
			if (!gotByePacket)
				e.printStackTrace();
		} catch (ClassNotFoundException e) {
			if (!gotByePacket)
				e.printStackTrace();
		}
	}

}
